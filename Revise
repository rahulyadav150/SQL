Q) There are 2 tables,first table has 5 records and second table has 10 records. you can assume any values in each of table.
how many maximum and minimum records possible in case of inner join,left join,right join and full outer join.
-----------------------------------------------------

Q) Problem with running sum
create table t (x int);

delete from t;

insert into t values(1),(2),(3),(1);

select x, sum(x) over (order by x) from t;
output - 
x sum(x)
1	2
1	2
2	4
3	7
if there are duplicates in order by then it consider both
 so we can resolve this in two ways
 select x, sum(x) over (order by x) from t;  adding one more column in order by so it become unique
 
 select x,sum(x) over(order by x rows between unbounded preceding and current row)   // 
 output-
x sum 
1	1
1	2
2	4
3	7


-----------------------------------------------------
Q) Count number of character and words in string.
create table strings (name varchar(50));
delete from strings;
insert into strings values ('Ankit Bansal'),('Ram Kumar Verma'),('Akshay Kumar Ak k'),('Rahul');
create table strings (name varchar(50));
delete from strings;
insert into strings values ('Ankit Bansal'),('Ram Kumar Verma'),('Akshay Kumar Ak k'),('Rahul');
---- count characters -------
select name,length(name) - length(replace(name,' ','')) cnt from strings;


-------count words words
>select name,(length(name) - length(replace(name,'wr','')))/length(wr) as cnt from strings;


---------------------------------------------------------------

Q) group by with window function
Ans-
with cte as (SELECT a.artist_name, 
dense_rank() over(order by count(r.rank) desc) as artist_rank
 FROM global_song_rank r LEFT JOIN songs s on r.song_id = s.song_id LEFT JOIN artists a on s.artist_id = a.artist_id where r.rank <= 10 
GROUP BY a.artist_name) 
SELECT * FROM cte WHERE artist_rank <= 5;

-------------------------------------------

Q) how to delete duplicates?

-----first approach -----------
create a backup table
delete all from original table
>insert into originaltable
select distinct * from backup table

distinct gives bad performance
>insert into original table
select col1,col2,coln from(
select col,col2,coln,row_number(partiton by col1 order by col2) rn from backup table
) where rn = 2;


---approch 2------

delete t1 from tablename t1 inner join (select col1,min(column which is differenct) form tablename group by col1 having count(1)>1) t2
on t1.col1 = t2.col1 // if table has multiple duplicates then run each time.

delete t1 from tablename t1 inner join (select col1,min(column which is differenct) form tablename  group by col1 having count(1)>1) t2
on t1.col1 = t2.col2 where t2.col is null; // run only one,delete all rows.

--approch 3 -----------

delete t1 from tablename t1 inner join (select *,row_number() over(partition by colname order by colname) rn from tableanme) t2
on t1.col = t2.col where rn >1
-----------------------------------------------

Q) create insert statement of a table containing data
>create table testing( `name` varchar(50),age int);
>delete from testing;
>insert into testing values('rahul',23),('rahul',25),('rahul',26);
>select concat('insert into testing values(',"'",name,"',",age,');') from testing;

--------------------------------------------------------------------------

Q) create points table for a tournament
create table icc_world_cup
(
Team_1 Varchar(20),
Team_2 Varchar(20),
Winner Varchar(20)
);
INSERT INTO icc_world_cup values('India','SL','India');
INSERT INTO icc_world_cup values('SL','Aus','Aus');
INSERT INTO icc_world_cup values('SA','Eng','Eng');


INSERT INTO icc_world_cup values('Eng','NZ','NZ');
INSERT INTO icc_world_cup values('Aus','India','India');
INSERT INTO icc_world_cup values('Aus','India','India');
select * from icc_world_cup;

with cte as(
select team_1 as team,winner from icc_world_cup
union all
select team_2 as team,winner from icc_world_cup
)
select team,count(1) total_played_matches,count(case when winner = team then 1 end) win_count,count(1)-count(case when winner = team then 1 end) lost_matches from cte group by team;

output
team  total_matches win matches lost matches
India	 3	            3	          0
SL	    2	            0	          2
SA	    1            	0	          1
Eng	   2	            1	          1
Aus	   3	            1	          2
NZ	    1	            1	          0

>with cte as(
select team_1 as team, case when winner = team_1 then 1 else 0 end as flag from icc_world_cup
union all
select team_2 as team,case when winner = team_2 then 1 else 0 end as flag from icc_world_cup



India, 3, 3, 0
SL, 2, 0, 2
SA, 1, 0, 1
Eng, 2, 1, 1
Aus, 3, 1, 2
NZ, 1, 1, 0


------------------------------------------------

Q) for every day find repeat customer and new customer
Ans-
create table customer_orders (
order_id integer,
customer_id integer,
order_date date,
order_amount integer
);
select * from customer_orders;
insert into customer_orders values(1,100,cast('2022-01-01' as date),2000),(2,200,cast('2022-01-01' as date),2500),(3,300,cast('2022-01-01' as date),2100)
,(4,100,cast('2022-01-02' as date),2000),(5,400,cast('2022-01-02' as date),2200),(6,500,cast('2022-01-02' as date),2700)
,(7,100,cast('2022-01-03' as date),3000),(8,400,cast('2022-01-03' as date),1000),(9,600,cast('2022-01-03' as date),3000);

--first approach---
select c1.order_date,count(case when c2.customer_id is null then 1 end ) count_new_customers,count(distinct c2.customer_id) count_pre_customers from customer_orders c1
left join (select customer_id,order_date from customer_orders) c2 on c1.customer_id = c2.customer_id and c1.order_date>c2.order_date group by c1.order_date;
-- 

---second approach--
with cte as (
select customer_id,min(order_date) first_order from customer_orders group by customer_id
)
select order_date,sum(case when order_date = first_order then 1 else 0 end) new_customers,sum(case when order_date !=first_order then 1 else 0 end) repeat_customers from customer_orders c inner join cte on c.customer_id = cte.customer_id group by order_date

---------------------------------

Q) find out most visited floor a each user,total visit and resource used
create table entries ( 
name varchar(20),
address varchar(20),
email varchar(20),
floor int,
resources varchar(10));

insert into entries 
values ('A','Bangalore','A@gmail.com',1,'CPU'),('A','Bangalore','A1@gmail.com',1,'CPU'),('A','Bangalore','A2@gmail.com',2,'DESKTOP')
,('B','Bangalore','B@gmail.com',2,'DESKTOP'),('B','Bangalore','B1@gmail.com',2,'DESKTOP'),('B','Bangalore','B2@gmail.com',1,'MONITOR');


with resources_count as (
select name,count(1) total_visit,group_concat(distinct resources) resources from entries group by name
),
floor_count as ( select name,floor from 
			(select name ,floor,count(1) as  count_floor_visited,row_number() over(partition by name  order by count(1) desc ) rn from entries group by name,floor)  A
             where rn = 1
	)
select f.name,rc.total_visit,f.floor most_visited_floor,rc.resources from resources_count rc inner join floor_count f on f.name = rc.name;


# name	total_visit	 most_visited_floor	  resources
A	     3	          1	                   CPU,DESKTOP
B	     3	          2	                   DESKTOP,MONITOR
----------------------------------------------------------------------

---------------------------------------------------------------------------------------

Q) find date for nth sunday from now
Ans-
set @n = 3;
set @d = '2023-02-26';

select date_add(@d,interval 7 - (weekday(@d)+1)%7 + 7*(@n-1)   day) nth_sunday;









